IMOBUNIFYDevelopment Guidelines & Best PracticesREGULI STRICTE DE DEZVOLTAREpentru evitarea refactorizărilor masive⚠️ ACEST DOCUMENT ESTE OBLIGATORIUOrice cod care nu respectă aceste reguli va fi respins.Versiune: 1.0 | Ianuarie 2026Cuprins1. Principii Fundamentale	41.1 SOLID Principles	4Single Responsibility Principle (SRP)	4Open/Closed Principle (OCP)	4Dependency Inversion Principle (DIP)	41.2 Regula Zero Magic Numbers/Strings	41.3 Configurabilitate vs Hardcoding	41.4 Separation of Concerns	52. Structura Proiectului	62.1 Monorepo Structure	62.2 Backend (apps/api) Structure	62.3 Frontend (apps/web, apps/admin) Structure	72.4 Naming Conventions	73. Reguli Backend (Node.js/Express)	93.1 Controller Rules	93.2 Service Rules	93.3 Repository Rules	103.4 Error Handling	123.5 Input Validation	133.6 API Response Format	153.7 Async/Await Rules	154. Reguli Frontend (React/Redux)	174.1 Component Rules	174.2 Component Organization	174.3 Redux Rules	184.4 Custom Hooks	204.5 Performance Rules	205. Reguli Bază de Date (PostgreSQL)	225.1 Schema Design Rules	225.2 Naming Conventions Database	225.3 Migration Rules	225.4 Query Optimization	235.5 Transactions	236. Reguli de Securitate	256.1 Authentication & Authorization	256.2 Input Sanitization	256.3 Sensitive Data	257. Reguli de Testing	277.1 Test Coverage Requirements	277.2 Test Structure	278. Git Workflow	288.1 Branch Strategy	288.2 Commit Messages	288.3 Pull Request Rules	289. Code Review Checklist	309.1 Functionality	309.2 Code Quality	309.3 Performance	309.4 Security	309.5 Testing	309.6 Documentation	3110. Quick Reference Card	32DO's (Întotdeauna)	32DON'Ts (Niciodată)	321. Principii FundamentaleAceste principii stau la baza tuturor deciziilor de dezvoltare. Încălcarea lor duce la cod greu de întreținut și refactorizări costisitoare.1.1 SOLID PrinciplesSingle Responsibility Principle (SRP)⛔ STRICT: Fiecare fișier/clasă/funcție are O SINGURĂ responsabilitate✅ DO: Un service pentru users, altul pentru listings, altul pentru payments❌ DON'T: Un 'MegaService' care face users + listings + payments + emailOpen/Closed Principle (OCP)⛔ STRICT: Codul trebuie să fie deschis pentru extensie, închis pentru modificare✅ DO: Adaugă funcționalitate nouă prin noi clase/module, nu modificând cele existente❌ DON'T: Modifica funcții existente pentru a adăuga cazuri noi (use strategy pattern)Dependency Inversion Principle (DIP)⛔ STRICT: Depinde de abstracții, nu de implementări concrete✅ DO: Injectează dependențele (database, services) prin constructor/parameters❌ DON'T: Import direct și instanțiere în funcții (face codul netestabil)1.2 Regula Zero Magic Numbers/Strings⛔ STRICT: NICIODATĂ hardcoded values în cod❌ GREȘIT✅ CORECTif (role === 'admin')if (role === ROLES.ADMIN)setTimeout(fn, 3600000)setTimeout(fn, TIME.ONE_HOUR_MS)if (status === 1)if (status === STATUS.ACTIVE)limit: 50limit: PAGINATION.DEFAULT_LIMITprice * 0.19price * TAX_RATES.VAT_STANDARD1.3 Configurabilitate vs Hardcoding⛔ STRICT: Tot ce poate varia TREBUIE să fie configurabilNivelUnde se configureazăExempleEnvironment.env fileDB_HOST, API_KEYS, PORTSRuntime ConfigDatabase (settings table)Feature flags, limitsAdmin ConfigAdmin Panel UIPlans, prices, AI modelsConstantsCod (constants.js)Enums, fixed business rules1.4 Separation of Concerns⛔ STRICT: Fiecare layer face DOAR ce îi este destinatLayerResponsabilitateNU faceControllerValidare input, routing, response formatBusiness logic, DB queriesServiceBusiness logic, orchestrareHTTP handling, direct DB accessRepositoryData access, queriesBusiness logic, validationModelData structure, relațiiBusiness logicMiddlewareCross-cutting concerns (auth, logging)Business logic2. Structura Proiectului2.1 Monorepo Structure⛔ STRICT: Structura de foldere este FIXĂ - nu se modifică fără aprobareimobunify/├── apps/│   ├── api/                 # Node.js REST API│   ├── web/                 # React user app│   ├── admin/               # React admin panel│   └── worker/              # Background jobs├── packages/│   ├── shared/              # Shared code (types, utils, constants)│   ├── database/            # Prisma schema, migrations, seeds│   └── integrations/        # Platform adapters├── docker/                  # Dockerfiles, compose├── scripts/                 # Build, deploy scripts└── docs/                    # Documentation2.2 Backend (apps/api) Structureapps/api/src/├── config/                  # App configuration│   ├── index.js             # Main config export│   ├── database.js│   └── services.js├── constants/               # Enums, magic values│   ├── index.js│   ├── roles.js│   ├── status.js│   └── errors.js├── controllers/             # Request handlers├── services/                # Business logic├── repositories/            # Data access├── middleware/              # Express middleware├── routes/                  # Route definitions├── utils/                   # Helper functions├── validators/              # Input validation schemas├── types/                   # TypeScript types└── app.js                   # Express app setup2.3 Frontend (apps/web, apps/admin) Structureapps/web/src/├── components/              # Reusable UI components│   ├── common/              # Buttons, inputs, etc│   ├── layout/              # Header, footer, sidebar│   └── features/            # Feature-specific components├── pages/                   # Page components (routes)├── store/                   # Redux store│   ├── index.js             # Store configuration│   ├── slices/              # Redux slices│   └── selectors/           # Memoized selectors├── hooks/                   # Custom React hooks├── services/                # API calls├── utils/                   # Helper functions├── constants/               # Frontend constants├── types/                   # TypeScript types└── styles/                  # Global styles, theme2.4 Naming Conventions⛔ STRICT: Naming conventions sunt OBLIGATORII pentru consistențăTipConventionExempluFolderekebab-caseuser-management/Fișiere JS/TScamelCaseuserService.jsFișiere React ComponentsPascalCaseUserProfile.jsxFișiere CSS/SCSSkebab-caseuser-profile.scssFișiere Test*.test.js sau *.spec.jsuserService.test.jsConstanteSCREAMING_SNAKE_CASEMAX_RETRY_COUNTFuncțiicamelCase, verb prefixgetUserById(), createListing()ClassesPascalCaseUserService, ListingRepositoryInterfaces/TypesPascalCase, prefix I/T opționalUser, IUserServiceDatabase tablessnake_case, pluralusers, property_listingsDatabase columnssnake_casecreated_at, user_idAPI endpointskebab-case, plural nouns/api/v1/user-profiles3. Reguli Backend (Node.js/Express)3.1 Controller Rules⛔ STRICT: Controllers doar orchestrează - NU conțin business logicTemplate OBLIGATORIU pentru controller:// ✅ CORECT - Controller curatasync getUser(req, res, next) {  try {    const { id } = req.params;    const user = await userService.getById(id);    res.json({ success: true, data: user });  } catch (error) {    next(error);  }}❌ DON'T: Business logic în controller:// ❌ GREȘIT - Logic în controllerasync getUser(req, res) {  const user = await prisma.user.findUnique({ where: { id } });  if (!user) throw new Error('Not found');  if (user.subscription.endDate < new Date()) { // Business logic!    user.status = 'expired';  }  res.json(user);}3.2 Service Rules⛔ STRICT: Services conțin TOATĂ business logic-aReguli pentru services:✅ DO: Fiecare service este o clasă sau modul cu metode clare✅ DO: Services primesc dependențele prin dependency injection✅ DO: Services returnează date, NU response objects✅ DO: Services aruncă custom errors (AppError, ValidationError)❌ DON'T: Services nu cunosc req/res - sunt framework-agnostic❌ DON'T: Services nu fac direct queries - folosesc repositoriesTemplate service:class UserService {  constructor(userRepository, subscriptionService) {    this.userRepo = userRepository;    this.subscriptionService = subscriptionService;  }  async getById(id) {    const user = await this.userRepo.findById(id);    if (!user) throw new NotFoundError('User', id);    return this.enrichUserData(user);  }  enrichUserData(user) {    return {      ...user,      isSubscriptionActive: this.subscriptionService.isActive(user.subscription)    };  }}3.3 Repository Rules⛔ STRICT: Repositories sunt SINGURA interfață cu baza de date✅ DO: Metode simple și focusate: findById, findMany, create, update, delete✅ DO: Metode de query complexe cu nume descriptive: findActiveByCity()✅ DO: Returnează entități pure, fără transformări business❌ DON'T: NICIODATĂ Prisma/Sequelize direct în services sau controllers❌ DON'T: Business logic în repositoryclass UserRepository {  constructor(prisma) {    this.prisma = prisma;  }  async findById(id) {    return this.prisma.user.findUnique({      where: { id },      include: { subscription: true }    });  }  async findActiveUsers(options = {}) {    const { limit = PAGINATION.DEFAULT, offset = 0 } = options;    return this.prisma.user.findMany({      where: { status: STATUS.ACTIVE },      take: limit,      skip: offset    });  }}3.4 Error Handling⛔ STRICT: TOATE erorile trec prin error handling middlewareIerarhie de erori custom:// errors/AppError.jsclass AppError extends Error {  constructor(message, statusCode, code) {    super(message);    this.statusCode = statusCode;    this.code = code;    this.isOperational = true;  }}class NotFoundError extends AppError {  constructor(resource, id) {    super(`${resource} with id ${id} not found`, 404, 'NOT_FOUND');  }}class ValidationError extends AppError {  constructor(errors) {    super('Validation failed', 400, 'VALIDATION_ERROR');    this.errors = errors;  }}Error middleware:// middleware/errorHandler.jsfunction errorHandler(err, req, res, next) {  // Log error  logger.error(err);  // Operational errors (expected)  if (err.isOperational) {    return res.status(err.statusCode).json({      success: false,      error: { code: err.code, message: err.message, errors: err.errors }    });  }  // Programming errors (unexpected) - don't leak details  res.status(500).json({    success: false,    error: { code: 'INTERNAL_ERROR', message: 'Something went wrong' }  });}3.5 Input Validation⛔ STRICT: TOATE inputurile sunt validate cu schema (Joi/Zod)✅ DO: Validare în middleware ÎNAINTE de controller✅ DO: Schema separată pentru fiecare endpoint✅ DO: Mesaje de eroare clare și utile❌ DON'T: Validare manuală în controller❌ DON'T: Trust input from client fără validare// validators/userValidators.jsconst Joi = require('joi');const createUserSchema = Joi.object({  email: Joi.string().email().required(),  password: Joi.string().min(8).required(),  name: Joi.string().min(2).max(100).required()});// middleware/validate.jsconst validate = (schema) => (req, res, next) => {  const { error, value } = schema.validate(req.body, { abortEarly: false });  if (error) {    const errors = error.details.map(d => ({ field: d.path[0], message: d.message }));    throw new ValidationError(errors);  }  req.validatedBody = value;  next();};3.6 API Response Format⛔ STRICT: Format UNIFORM pentru toate response-urileSuccess response:{  "success": true,  "data": { ... },  "meta": {                    // Optional, for pagination    "page": 1,    "limit": 20,    "total": 150,    "totalPages": 8  }}Error response:{  "success": false,  "error": {    "code": "VALIDATION_ERROR",    "message": "Validation failed",    "errors": [                // Optional, for validation      { "field": "email", "message": "Invalid email format" }    ]  }}3.7 Async/Await Rules⛔ STRICT: ÎNTOTDEAUNA async/await, NICIODATĂ callbacks sau .then() chains✅ DO: async/await pentru toate operațiile asincrone✅ DO: try/catch sau asyncHandler wrapper❌ DON'T: Callback hell sau .then().then().then()❌ DON'T: Mix între callbacks și promises// utils/asyncHandler.jsconst asyncHandler = (fn) => (req, res, next) => {  Promise.resolve(fn(req, res, next)).catch(next);};// Usage in routesrouter.get('/users/:id', asyncHandler(userController.getUser));4. Reguli Frontend (React/Redux)4.1 Component Rules⛔ STRICT: Componente mici, focusate, reutilizabile✅ DO: Functional components cu hooks (nu class components)✅ DO: Componente < 200 linii (ideal < 100)✅ DO: Props destructuring în parametri✅ DO: PropTypes sau TypeScript pentru type checking❌ DON'T: Componente monolitice cu sute de linii❌ DON'T: Logică complexă în componente - extrage în hooks/utils// ✅ CORECT - Component curatfunction UserCard({ user, onEdit, onDelete }) {  const { name, email, avatarUrl } = user;    return (    <Card>      <Avatar src={avatarUrl} alt={name} />      <CardContent>        <Typography variant="h6">{name}</Typography>        <Typography color="textSecondary">{email}</Typography>      </CardContent>      <CardActions>        <Button onClick={() => onEdit(user.id)}>Edit</Button>        <Button onClick={() => onDelete(user.id)}>Delete</Button>      </CardActions>    </Card>  );}4.2 Component Organization⛔ STRICT: Separare clară: containers vs presentational componentsTipRolStateReduxPresentationalUI renderingLocal only (hover, input)NuContainerData fetching, logicDaDa (useSelector, dispatch)PageRoute component, layoutMinimalOpțional4.3 Redux Rules⛔ STRICT: Redux DOAR pentru global state, NU pentru form inputsÎn Redux (global)NU în Redux (local state)User authentication stateForm input valuesCurrent user profileUI state (modal open/close)Listings from APIHover statesFilters și search paramsLoading states specifice componenteiShopping cart / saved itemsTemporary input valuesRedux Toolkit slice template:// store/slices/usersSlice.jsimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';import { userService } from '../../services/userService';export const fetchUsers = createAsyncThunk(  'users/fetchUsers',  async (params, { rejectWithValue }) => {    try {      return await userService.getUsers(params);    } catch (error) {      return rejectWithValue(error.response?.data || error.message);    }  });const usersSlice = createSlice({  name: 'users',  initialState: {    items: [],    status: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'    error: null  },  reducers: { clearError: (state) => { state.error = null; } },  extraReducers: (builder) => {    builder      .addCase(fetchUsers.pending, (state) => { state.status = 'loading'; })      .addCase(fetchUsers.fulfilled, (state, action) => {        state.status = 'succeeded';        state.items = action.payload;      })      .addCase(fetchUsers.rejected, (state, action) => {        state.status = 'failed';        state.error = action.payload;      });  }});4.4 Custom Hooks⛔ STRICT: Logica reutilizabilă TREBUIE extrasă în custom hooks✅ DO: Prefix 'use' pentru toate custom hooks✅ DO: Un hook = o responsabilitate✅ DO: Hooks pentru: API calls, form handling, local storage, etc.❌ DON'T: Duplicare logică între componente// hooks/useApi.js - Generic API hookfunction useApi(apiFunction) {  const [data, setData] = useState(null);  const [loading, setLoading] = useState(false);  const [error, setError] = useState(null);  const execute = useCallback(async (...args) => {    setLoading(true);    setError(null);    try {      const result = await apiFunction(...args);      setData(result);      return result;    } catch (err) {      setError(err);      throw err;    } finally {      setLoading(false);    }  }, [apiFunction]);  return { data, loading, error, execute };}// Usageconst { data: users, loading, error, execute: fetchUsers } = useApi(userService.getUsers);4.5 Performance Rules⛔ STRICT: Optimizare obligatorie pentru liste și re-renders✅ DO: React.memo() pentru componente care primesc aceleași props✅ DO: useMemo() pentru calcule costisitoare✅ DO: useCallback() pentru funcții pasate ca props✅ DO: Key unic și stabil pentru liste (NU index!)✅ DO: Virtualizare pentru liste mari (react-window)❌ DON'T: Inline functions în JSX pentru event handlers❌ DON'T: Object/array literals în props (creează referințe noi)// ❌ GREȘIT - Re-render la fiecare parent render<Button onClick={() => handleClick(id)} /><List items={items.filter(i => i.active)} />// ✅ CORECT - Referințe stabileconst handleClick = useCallback(() => { ... }, [id]);const activeItems = useMemo(() => items.filter(i => i.active), [items]);<Button onClick={handleClick} /><List items={activeItems} />5. Reguli Bază de Date (PostgreSQL)5.1 Schema Design Rules⛔ STRICT: Design-ul schemei este CRITIC - greșelile sunt costisitoare✅ DO: Normalizare până la 3NF minim✅ DO: Foreign keys pentru toate relațiile✅ DO: Indexes pe coloanele folosite în WHERE și JOIN✅ DO: Timestamps pe toate tabelele (created_at, updated_at)✅ DO: Soft delete (deleted_at) în loc de DELETE fizic❌ DON'T: Duplicate data care poate fi JOIN-uit❌ DON'T: JSON columns pentru date care ar trebui normalizate❌ DON'T: Missing indexes pe foreign keys5.2 Naming Conventions Database⛔ STRICT: Naming conventions FIXE pentru consistențăElementConventionExempluTablessnake_case, pluralusers, property_listingsColumnssnake_casecreated_at, user_idPrimary Keyid (UUID)id UUID PRIMARY KEYForeign Keyreferenced_table_iduser_id, listing_idIndexesidx_table_column(s)idx_users_emailUnique constraintsuq_table_columnuq_users_emailCheck constraintschk_table_descriptionchk_price_positiveEnumssnake_caseuser_role, listing_statusJunction tablestable1_table2 (alphabetic)listings_tags5.3 Migration Rules⛔ STRICT: TOATE modificările de schemă prin migrări Prisma✅ DO: O migrare = o schimbare logică✅ DO: Nume descriptive: add_price_history_to_listings✅ DO: Testează migrarea pe copy a DB înainte de producție✅ DO: Backward compatible când posibil❌ DON'T: Editare manuală a DB în producție❌ DON'T: Migrări care pierd date fără backup❌ DON'T: Redenumire masivă de coloane (breaking change)5.4 Query Optimization⛔ STRICT: Queries trebuie optimizate ÎNAINTE de production❌ Anti-pattern✅ Best PracticeSELECT *SELECT doar coloanele necesareN+1 queries în loopEager loading / JOINQuery în loopBatch query cu IN clauseLIKE '%text%' (no index)Full-text search sau prefix LIKE 'text%'ORDER BY pe coloană neindexatăIndex pe coloana de sortareCOUNT(*) pe tabele mariApproximate count sau cacheN+1 Problem - EXEMPLU:// ❌ N+1 PROBLEM - 1 query + N queriesconst listings = await prisma.listing.findMany();for (const listing of listings) {  listing.user = await prisma.user.findUnique({ where: { id: listing.userId } });}// ✅ CORECT - 1 query cu includeconst listings = await prisma.listing.findMany({  include: { user: true }});5.5 Transactions⛔ STRICT: Operații multiple pe tabele = TRANSACTION// ✅ CORECT - Transaction pentru consistențăawait prisma.$transaction(async (tx) => {  const user = await tx.user.create({ data: userData });  await tx.subscription.create({    data: { userId: user.id, planId: freePlanId }  });  await tx.auditLog.create({    data: { action: 'USER_CREATED', resourceId: user.id }  });});6. Reguli de Securitate6.1 Authentication & Authorization⛔ STRICT: TOATE endpoint-urile protejate au auth check✅ DO: JWT tokens cu expirare scurtă (15 min access, 7 days refresh)✅ DO: Refresh token rotation (invalidează old token la refresh)✅ DO: Role-based access control (RBAC)✅ DO: Middleware auth pe route group, nu individual❌ DON'T: Secrets în cod sau git❌ DON'T: Token-uri fără expirare❌ DON'T: Verificare rol doar pe frontend6.2 Input Sanitization⛔ STRICT: NICIODATĂ trust user inputAttackPrevențieSQL InjectionParameterized queries (Prisma face automat)XSSEscape output, Content-Security-Policy headerCSRFCSRF tokens, SameSite cookiesPath TraversalValidare și sanitizare file pathsCommand InjectionNu exec() cu user input, whitelist commands6.3 Sensitive Data⛔ STRICT: Date sensibile tratate cu grijă maximă✅ DO: Passwords: bcrypt cu cost 12+✅ DO: API keys: encrypted în DB cu key din env✅ DO: PII: audit log pentru access✅ DO: Logs: nu include passwords, tokens, card numbers❌ DON'T: Password în plain text sau MD5/SHA1❌ DON'T: Secrets în error messages sau logs❌ DON'T: API keys în frontend code7. Reguli de Testing7.1 Test Coverage Requirements⛔ STRICT: Minimum 80% coverage pentru services și utilsLayerTest TypeCoverage MinFocusServicesUnit tests90%Business logic, edge casesRepositoriesIntegration tests80%Query correctnessControllersIntegration tests70%Request/response flowUtilsUnit tests95%All functionsComponentsUnit + snapshot70%Rendering, interactions7.2 Test StructureStructura AAA (Arrange, Act, Assert):describe('UserService', () => {  describe('getById', () => {    it('should return user when found', async () => {      // Arrange      const mockUser = { id: '123', email: 'test@test.com' };      userRepo.findById.mockResolvedValue(mockUser);      // Act      const result = await userService.getById('123');      // Assert      expect(result).toEqual(mockUser);      expect(userRepo.findById).toHaveBeenCalledWith('123');    });    it('should throw NotFoundError when user not found', async () => {      userRepo.findById.mockResolvedValue(null);      await expect(userService.getById('999')).rejects.toThrow(NotFoundError);    });  });});8. Git Workflow8.1 Branch Strategy⛔ STRICT: GitFlow simplificat - branch-uri clareBranchPurposeMerge IntoProtectedmainProduction code-✅ YesdevelopIntegration branchmain✅ Yesfeature/*New featuresdevelop❌ Nobugfix/*Bug fixesdevelop❌ Nohotfix/*Urgent prod fixesmain + develop❌ Norelease/*Release preparationmain + develop❌ No8.2 Commit Messages⛔ STRICT: Conventional Commits formatFormat: type(scope): descriptionTypeWhen to useExamplefeatNew featurefeat(auth): add password reset flowfixBug fixfix(listings): correct price calculationrefactorCode restructurerefactor(api): extract validation middlewaredocsDocumentationdocs(readme): add setup instructionstestTeststest(userService): add edge case testschoreMaintenancechore(deps): update dependencies8.3 Pull Request Rules⛔ STRICT: TOATE schimbările prin PR cu review✅ DO: Descriere clară a ce face PR-ul✅ DO: Link la task/issue✅ DO: Screenshots pentru UI changes✅ DO: Self-review înainte de request review✅ DO: Max 400 linii changed (split dacă mai mare)❌ DON'T: Merge fără review❌ DON'T: Merge cu failing tests❌ DON'T: Force push pe branch-uri shared9. Code Review ChecklistFolosește acest checklist pentru FIECARE code review:9.1 Functionality□ Codul face ce trebuie să facă?□ Edge cases sunt tratate?□ Error handling este complet?9.2 Code Quality□ Respectă naming conventions?□ Nu are magic numbers/strings?□ Funcțiile sunt mici și focusate?□ Nu are cod duplicat?□ Separation of concerns respectată?9.3 Performance□ Nu are N+1 queries?□ Queries sunt optimizate?□ Nu are memory leaks (event listeners, subscriptions)?□ Componente React sunt optimizate (memo, useCallback)?9.4 Security□ Input validation prezentă?□ Authorization verificată?□ Nu expune date sensibile?□ Nu are vulnerabilități cunoscute?9.5 Testing□ Tests pentru happy path?□ Tests pentru error cases?□ Tests trec local?9.6 Documentation□ Funcții complexe au comentarii?□ README actualizat dacă e nevoie?□ API docs actualizate?10. Quick Reference CardPrintează această pagină și ține-o la îndemână:DO's (Întotdeauna)✅ Constants pentru magic values✅ Validation pe toate inputurile✅ Error handling cu custom errors✅ Async/await pentru async code✅ Repository pentru DB access✅ Service pentru business logic✅ Custom hooks pentru logic reutilizabilă✅ Tests pentru services și utils✅ PR review înainte de mergeDON'Ts (Niciodată)❌ Hardcoded values în cod❌ Business logic în controllers❌ Prisma direct în services❌ Callbacks sau .then() chains❌ SELECT * în queries❌ N+1 queries❌ Inline functions în JSX props❌ Form state în Redux❌ Secrets în cod sau git❌ Merge fără review sau cu failing tests═══════════════════════════════════════RESPECTĂ ACESTE REGULI = COD MENTENABIL═══════════════════════════════════════
